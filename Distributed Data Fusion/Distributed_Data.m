clear all; % 清除工作区中的所有变量
clc;       % 清除命令窗口内容

% =========================================================================
% 分布式数据融合算法 - 基于Dempster-Shafer证据理论和线性共识
% =========================================================================
% 本代码实现了一个分布式系统中多个节点（智能体）通过共识算法
% 融合证据信息的过程。算法基于Dempster-Shafer证据理论，在对数域
% 进行线性共识，最终得到全局一致的信念函数。

n = 5;         % 网络中的节点数量（智能体数量）
format long;   % 设置数值显示格式为长格式，提高精度

% W矩阵：权重矩阵，用于分布式共识算法
% 这是一个双随机矩阵，每行和每列的元素和都为1
% W(i,j)表示节点i从节点j接收信息时的权重系数
% 矩阵的稀疏性反映了网络的通信拓扑结构
W = [ 0.417  0.333  0.250  0.000  0.000;    % 节点1的邻居权重分配
      0.333  0.667  0.000  0.000  0.000;    % 节点2的邻居权重分配
      0.250  0.000  0.250  0.250  0.250;    % 节点3的邻居权重分配（连接最多）
      0.000  0.000  0.250  0.750  0.000;    % 节点4的邻居权重分配
      0.000  0.000  0.250  0.000  0.750 ];  % 节点5的邻居权重分配

% mass矩阵：每个节点的初始质量函数（Mass Function）
% 在Dempster-Shafer证据理论中，质量函数表示对不同命题的信度分配
% 每行对应一个节点，每列对应不同的命题集合：
% 第1列：m({ω1}) - 对命题ω1的信度
% 第2列：m({ω2}) - 对命题ω2的信度  
% 第3列：m({ω1,ω2}) - 对命题ω1和ω2都成立的信度
% 第4列：m(∅) - 对空集的信度（通常为0，表示冲突）
mass = [
    0.848  0.116  0.036  0.000;    % 节点1：强烈支持ω1
    0.092  0.127  0.780  0.000;    % 节点2：强烈支持ω1∪ω2
    0.353  0.632  0.016  0.000;    % 节点3：倾向于支持ω2
    0.430  0.370  0.200  0.000;    % 节点4：对ω1和ω2的支持相对平均
    0.480  0.380  0.140  0.000     % 节点5：略微倾向于ω1
];

% =========================================================================
% 第一步：从质量函数计算Q函数（置信函数）
% =========================================================================
% Q函数（也称为置信函数或Belief函数）表示对某个命题至少成立的信度
% 对于任意集合A，Q(A) = Σ_{B⊆A} m(B)，即所有子集的质量函数之和

Q = zeros(n, 4);  % 初始化Q函数矩阵，n×4表示n个节点对4个集合的置信度

for i = 1:n
    % 对每个节点i，计算其对不同命题集合的置信函数值
    Q(i,1) = mass(i,1) + mass(i,3);  % Q_i({ω1}) = m({ω1}) + m({ω1,ω2})
    Q(i,2) = mass(i,2) + mass(i,3);  % Q_i({ω2}) = m({ω2}) + m({ω1,ω2})
    Q(i,3) = mass(i,3);              % Q_i({ω1,ω2}) = m({ω1,ω2})
    Q(i,4) = 1;                      % Q_i(∅) = 1，全集的置信度总是1
end

% =========================================================================
% 第二步：将Q函数转换为对数域（log-Q）
% =========================================================================
% 在对数域进行运算有以下优势：
% 1. 将乘法运算转换为加法运算，便于线性共识算法处理
% 2. 提高数值计算的稳定性，避免很小的数值导致的精度损失
% 3. 对数函数的单调性保持了原始信息的相对关系

logQ = log(Q);

% =========================================================================
% 第三步：初始化状态矩阵X用于共识算法
% =========================================================================
% X矩阵存储每个节点的log-Q值，将作为共识算法的状态变量
% X(i,:)表示节点i对所有命题的log-Q向量

X = logQ;

% =========================================================================
% 第四步：线性共识算法的可视化仿真
% =========================================================================
% 通过多次迭代展示各节点log-Q值如何逐渐收敛到一致状态
% 线性共识算法的核心思想：每个节点的状态更新为其邻居状态的加权平均

iterations = 100;  % 设置共识迭代次数
figure;            % 创建新的图形窗口
hold on;           % 保持图形，使后续绘图命令添加到同一图上

% 开始迭代仿真过程
for t = 1:iterations
    % 同步更新：所有节点同时根据权重矩阵W更新其状态
    % X_new = W * X 实现了分布式平均共识算法的一次迭代
    % 每个节点的新状态 = Σ W(i,j) * X_old(j,:)
    X_new = W * X;  
    X = X_new;      % 更新状态矩阵
    
    % 可视化当前迭代的log-Q值分布情况
    % 不同颜色表示不同的命题，不同的点表示不同的节点
    plot(t*ones(1, n), X(:,1), 'ro');  % 红色圆点：{ω1}的log-Q值
    plot(t*ones(1, n), X(:,2), 'go');  % 绿色圆点：{ω2}的log-Q值  
    plot(t*ones(1, n), X(:,3), 'bo');  % 蓝色圆点：{ω1,ω2}的log-Q值
end

% 设置图形标签和标题，便于理解仿真结果
xlabel('迭代次数');                    % x轴：迭代轮数
ylabel('log-Q 值');                   % y轴：对数置信度值
title('log-Q值在迭代过程中的收敛情况');   % 图形标题
legend({'log-Q for {ω₁}', 'log-Q for {ω₂}', 'log-Q for {ω₁,ω₂}'});  % 图例说明
hold off;                            % 释放图形保持状态

% =========================================================================
% 第五步：计算全局共识结果
% =========================================================================
% 经过共识算法后，所有节点的log-Q值应该收敛到相同的值
% 这里计算所有节点的平均值作为全局共识的log-Q

alpha_k = mean(X, 1);  % 按列计算均值，得到每个命题的全局平均log-Q值
                       % alpha_k(j)表示所有节点对命题j达成共识的log-Q值

% =========================================================================
% 第六步：从共识的log-Q恢复全局Q函数
% =========================================================================
% 根据分布式信息融合理论，全局Q函数可以通过以下公式计算：
% Q_global(A) = exp(n * α_k(A))，其中n是节点数，α_k是共识的平均log-Q

Q_total = exp(n * alpha_k);  % 计算融合后的全局Q函数

% =========================================================================
% 第七步：通过Möbius逆变换计算全局质量函数
% =========================================================================
% Möbius逆变换是从Q函数（置信函数）恢复质量函数的标准方法
% 对于二元命题空间{ω1, ω2}，逆变换公式为：
% m(A) = Σ_{B⊇A} (-1)^|B\A| Q(B)

m_unnorm = zeros(1, 4);  % 初始化未归一化的质量函数
m_unnorm(1) = Q_total(1) - Q_total(3);  % m({ω1}) = Q({ω1}) - Q({ω1,ω2})
m_unnorm(2) = Q_total(2) - Q_total(3);  % m({ω2}) = Q({ω2}) - Q({ω1,ω2})
m_unnorm(3) = Q_total(3);               % m({ω1,ω2}) = Q({ω1,ω2})
m_unnorm(4) = Q_total(4) - Q_total(1) - Q_total(2) + Q_total(3);  % m(∅)，空集的质量

% =========================================================================
% 第八步：质量函数的归一化处理
% =========================================================================
% 由于数值计算误差，可能会产生非零的空集质量m(∅)
% 需要进行Dempster归一化以确保质量函数的有效性

K = 1 / (1 - m_unnorm(4));  % 计算归一化常数K = 1/(1-m(∅))
m_norm = m_unnorm * K;      % 归一化：将非空集的质量按比例放大

% =========================================================================
% 第九步：输出最终的融合结果
% =========================================================================
% ----- 验证：打印归一化后质量函数之和，检查是否为1 -----
sum_m = m_norm(1)+m_norm(2)+m_norm(3);
fprintf('\n[检查] 归一化后 mass 之和 = %.12f (应接近 1.0)\n', sum_m);
if abs(sum_m - 1) < 1e-9
    fprintf('[检查结果] 和为1：OK\n\n');
else
    fprintf('[检查结果] 和不为1：差值 = %.6e\n\n', sum_m - 1);
end

fprintf('=== 分布式信息融合结果 ===\n');
fprintf('经过 %d 次迭代后的全局质量函数：\n', iterations);
fprintf('m({ω₁}) = %.6f\n', m_norm(1));      % 对ω1的全局信度
fprintf('m({ω₂}) = %.6f\n', m_norm(2));      % 对ω2的全局信度  
fprintf('m({ω₁,ω₂}) = %.6f\n', m_norm(3));   % 对ω1∪ω2的全局信度
fprintf('归一化常数 K = %.6f\n', K);          % 显示归一化系数
