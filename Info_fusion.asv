function [Value_data] = Info_fusion(Value_data, Graph, Value_Params,W)

% 共识参数设置
max_consensus_iter = 1000;  % 最大共识迭代次数
consensus_tolerance = 1e-4;  % 收敛容忍度

% =========================================================================
% 步骤3.1：通过通信图G计算Metropolis-Hastings权重矩阵W
% =========================================================================
N = Value_Params.N;
M = Value_Params.M;
K = Value_Params.K;             % 三种任务类型


%% 第一步：计算局部信念Mass函数（基于个体观测数据）
for i = 1:Value_Params.N
    for j = 1:Value_Params.M
        % 计算对于任务类型j的观测次数
        total_obs = Value_data(i).observe(j,1) + Value_data(i).observe(j,2) + Value_data(i).observe(j,3);

        % 如果有观测数据
        if total_obs > 0
            % 基于自己的观测次数计算个体信念概率：个体观测某类型次数/总观测次数
            % Value_data(i).initbelief(j,k) 表示智能体i认为任务j属于类型k的概率
            Value_data(i).initbelief(j,1) = Value_data(i).observe(j,1) / total_obs; % 任务j为类型1(价值300)的概率
            Value_data(i).initbelief(j,2) = Value_data(i).observe(j,2) / total_obs; % 任务j为类型2(价值500)的概率
            Value_data(i).initbelief(j,3) = Value_data(i).observe(j,3) / total_obs; % 任务j为类型3(价值1000)的概率
        else
            % 如果没有观测数据，保持原来不变（通常为初始的均匀分布）
            Value_data(i).initbelief(j,1:end) = Value_data(i).initbelief(j,1:end);
        end
    end
end


%% 第二步：计算共性函数（信念值的对数变换）
% 每个智能体有一个j*k（6*3）的一个矩阵记录着对 每个任务的信念值的共性函数
for i = 1:Value_Params.N    % i: 智能体索引 (1到N)，遍历所有智能体
    for j = 1:Value_Params.M    % j: 任务索引 (1到M)，遍历所有任务
        for k = 1:3    % k: 任务类型索引 (1到3)，对应三种可能的任务价值类型
            % =====================================================================
            % i, j, k 三重循环的详细含义：
            % =====================================================================
            % 例如：i=2, j=3, k=1 表示：
            % "智能体2对任务3为价值类型1(300)的信念进行对数变换"
            % =====================================================================
            % 对信念值取对数得到共性函数
            % Value_data(i).initbelief(j,k) 表示智能体i对任务j属于类型k的信念概率
            % 添加小常数避免log(0)的数值问题
            epsilon = 1e-10;
            Value_data(i).commonality(j,k) = log(Value_data(i).initbelief(j,k) + epsilon);
            % 结果：智能体i对任务j属于类型k的对数信念值（共性函数）
        end
    end
end


%% 第三步：线性共识算法

for consensus_iter = 1:max_consensus_iter

    X_old = zeros(N, M*K);

    for i = 1:N
        tmp = Value_data(i).commonality;  % M × K

        % 确保展平的顺序是：任务1类型1, 任务1类型2, 任务2类型1, 任务2类型2, ...
        X_old(i,:) = reshape(tmp', 1, M*K); 

    end


    X = W * X_old;   % W 是 N×N，每一列对应一个 (j,k) 的共识

    %=========== 3. 把更新后的 X 写回到 Value_data(i).commonality ===========%
    for i = 1:N
        tmp = reshape(X(i,:),[K, M])';    % 还原成 M × K 矩阵
        Value_data(i).commonality = tmp;   % 更新智能体的 commonality
    end


    %=========== 4. 检查收敛性：看本轮前后变化是否足够小 ===========%
    max_change = max(max(abs(X - X_old)));
    fprintf('共识第 %d 轮：max_change = %.6e\n', consensus_iter, max_change);

    if max_change < consensus_tolerance
        fprintf('共识算法在第 %d 次迭代后收敛\n', consensus_iter);
        break;
    end
end

% =====================================================================================


%% 第四步：转换回信念值
for i = 1:Value_Params.N  % 遍历所有智能体
    for j = 1:Value_Params.M  % 遍历所有任务
        for k = 1:3  % 遍历任务的三种类型（根据任务类型数量K）
            % 步骤 1: 从对数形式恢复信念值
            Value_data(i).commonality(j,k) = exp(Value_Params.N * Value_data(i).commonality(j,k));  % 转换回信念值
            % 对应公式: Q(A) = exp(n * α_k(A))，恢复信念值

            % 步骤 2: 计算每个任务类型的未归一化质量函数
            m_unnorm(k) = Value_data(i).initbelief(j,k);  % 获取当前任务类型的信念
            % 对应公式: m(ω_k) = Q(ω_k)（提取任务类型k的信念值）

            % 步骤 3: 计算空集的质量（根据其他所有类型的质量来计算）
            if k == 3  % 只在最后一次计算空集的质量
                m_unnormempty = 1 - sum(m_unnorm);  % 空集的质量 = 1 - 所有其他任务类型的质量之和
                % 对应公式: m(0) = 1 - ∑_{k=1}^{K} m(ω_k)（空集的质量）
            end

            % 打印当前信念和计算的空集质量
            fprintf('Task j = %d, Type k = %d, Belief = %.6e\n', j, k, Value_data(i).initbelief(j,k));
            if k == 3
                fprintf('Empty set m(?) = %.6e\n', m_unnormempty);  % 输出空集质量
            end
        end

        % 步骤 4: 归一化质量函数
        K = 1 / (1 - m_unnormempty);  % 计算归一化常数 K
        % 对应公式: K = 1 / (1 - m(?))（归一化常数，确保质量函数加和为1）

        if total_belief > 0
            % 如果有足够的信念，按照归一化常数调整
            Value_data(i).initbelief(j,:) = K * Value_data(i).initbelief(j,:);
            % ---------- 验证：打印归一化后质量函数之和 ----------
            s = sum(Value_data(i).initbelief(j,:));
            fprintf('\n[检查] 智能体 %d, 任务 %d: 归一化后 initbelief 之和 = %.12f (应接近 1.0)\n', i, j, s);
            if abs(s - 1) < 1e-9
                fprintf('[检查结果] 和为1：OK\n');
            else
                fprintf('[检查结果] 和不为1：差值 = %.6e\n', s - 1);
            end
        else
            % 如果没有有效的信念，使用均匀分布
            Value_data(i).initbelief(j,:) = [1/3, 1/3, 1/3];  % 均匀分布
        end
    end
end

end
